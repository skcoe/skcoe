package com.skcoe18.util;

import java.util.Hashtable;

public abstract class Logger
{
  public static final int ERROR_LEVEL = 0;
  public static final int WARNING_LEVEL = 1;
  public static final int INFORMATION_LEVEL = 2;
  public static final int VERBOSE_LEVEL = 3;
  public static final String ERROR_LEVEL_LABEL = "error";
  public static final String WARNING_LEVEL_LABEL = "warning";
  public static final String INFORMATION_LEVEL_LABEL = "information";
  public static final String VERBOSE_LEVEL_LABEL = "verbose";
  protected int mLogLevel = 2;

  protected String mLoggerName = null;
  private static final String LOGGER_PROPERTIES = "logger.properties";
  protected static Logger mDefaultLogger = null;

  private static Hashtable mLoggerTable = new Hashtable();

  public static void initDefaultLogger()
  {
    mDefaultLogger = new Logger();
    mDefaultLogger.setName("default");
    try {
      mDefaultLogger.init(null);
    }
    catch (Exception e)
    {
    }
  }

  private static Logger loadLogger(String logger_name, Properties logger_prop, ClassLoader cl) {
    String class_imp = logger_prop.getProperty(logger_name + ".class");

    if (class_imp == null) {
      return null;
    }
    String log_level_c = logger_prop.getProperty(logger_name + ".level", "2");
    int log_level = 2;

    if (log_level_c == null)
      log_level = 2;
    else if (log_level_c.equalsIgnoreCase("error"))
      log_level = 0;
    else if (log_level_c.equalsIgnoreCase("warning"))
      log_level = 1;
    else if (log_level_c.equalsIgnoreCase("information"))
      log_level = 2;
    else if (log_level_c.equalsIgnoreCase("verbose"))
      log_level = 3;
    else try {
        log_level = Integer.parseInt(log_level_c);
      }
      catch (Exception e) {
      } Properties init_prop = new Properties();
    String init_conf = logger_name + ".init.";

    Enumeration prop_names = logger_prop.propertyNames();
    while (prop_names.hasMoreElements()) {
      String prop_name = (String)prop_names.nextElement();

      if (prop_name.indexOf(init_conf) == 0) {
        String prop_init_name = prop_name.substring(init_conf.length());
        String prop_init_value = logger_prop.getProperty(prop_name);
        init_prop.setProperty(prop_init_name, prop_init_value);
      }
    }

    try
    {
      return create(logger_name, class_imp, log_level, init_prop, cl);
    } catch (Exception e) {
      e.printStackTrace();
    }return null;
  }

  public static synchronized Logger getLogger(String logger_name)
  {
    return getLogger(logger_name, null);
  }

  public static synchronized Logger getLogger(String logger_name, ClassLoader cl)
  {
    if (logger_name == null) {
      logger_name = "default";
    }
    Properties logger_prop = new Properties();
    if (cl == null) {
      cl = Logger.class.getClassLoader();
    }

    InputStream in = cl.getResourceAsStream("logger.properties");
    try {
      if (in != null) try {
          logger_prop.load(in); } catch (Exception e) {
        } 
    } finally { if (in != null) try { in.close(); } catch (Exception e)
        {
        }  }
    Logger sel_logger = loadLogger(logger_name, logger_prop, cl);

    if ((sel_logger == null) && (!logger_name.equals("default"))) {
      sel_logger = loadLogger("default", logger_prop, cl);
    }
    if (sel_logger == null)
    {
      if (mDefaultLogger == null)
        initDefaultLogger();
      sel_logger = mDefaultLogger;
    }
    return sel_logger;
  }

  private static Logger create(String logger_name, String logger_classname, int logger_level, Properties logger_envs, ClassLoader cl)
    throws ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    Class logger_class = Class.forName(logger_classname, true, cl);
    Logger logger = (Logger)logger_class.newInstance();
    logger.setName(logger_name);
    logger.setLogLevel(logger_level);
    logger.init(logger_envs);
    return logger;
  }

  public String getName()
  {
    return this.mLoggerName;
  }
  void setName(String logger_name) {
    this.mLoggerName = logger_name;
  }

  public void logException(Throwable e)
  {
    String error_message = e.toString();
    StackTraceElement[] trace_elements = e.getStackTrace();
    for (int i = 0; i < trace_elements.length; i++)
      error_message = error_message + "\n" + trace_elements[i].toString();
    logError(error_message);
  }

  public void logError(String message)
  {
    logMessage(0, message);
  }

  public void logWarning(String message)
  {
    logMessage(1, message);
  }

  public void logInformation(String message)
  {
    logMessage(2, message);
  }

  public void logVerbose(String message)
  {
    logMessage(3, message);
  }

  public void logMessage(int level, String message)
  {
    if (level > this.mLogLevel) return;
    log(level, message, new Date());
  }

  public void setLogLevel(int loglevel)
  {
    if (loglevel > 3)
      loglevel = 3;
    else if (loglevel < 0)
      loglevel = 0;
    this.mLogLevel = loglevel;
  }

  public int getLogLevel()
  {
    return this.mLogLevel;
  }

  public static String getLevelName(int level)
  {
    switch (level) { case 0:
      return "Error";
    case 1:
      return "Warning";
    case 2:
      return "Information";
    }
    return "Verbose";
  }

  protected abstract void log(int paramInt, String paramString, Date paramDate);

  protected abstract void init(Properties paramProperties)
    throws InstantiationException;
}
